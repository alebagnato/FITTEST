<html>
<head>
<link rel="stylesheet" type="text/css" href="docs.css" /> 
</head>
<body>

<h1>haslog</h1>

<p>Haslog provides a number of format conversions for FITTEST-format
logs, such as conversion to XML and to the Daikon format.

<p class="legalstuff"><b>License:</b> BSD3</p>

<h3>General Usage</h3>

<p>
haslog --help
<br>haslog options+ logfile
</p>

<h3>Options</h3>

<ul class=optionlist> 
   <li>
   <dl><dt>--help</dt>  <dd>Obvious.</dd></dl>
   </li>
   
   <li>
   <dl><dt>-c  --compress</dt>
   
   <dd>
   Produce a compressed version of the input logfile. The input
   logfile is a UTF8 text-file in the FITTEST-format and is assumed to
   have .log extension.

   The compression produces two files: name.lox which contains the
   compressed version of name.log, and name.dic which contains the
   dictionary of the compression. The compression algorithm currently
   works simply based on indexing common tags and sentences in name.log;
   positive compression is not guaranteed.
   </dd>
   </dl>
   </li>

  <li><dl><dt>--rstat</dt>

  <dd>Print the statistics of the input FITTEST-format logfile
   (name.log).</dd>
  </dl>
  </li>

  <li>
  <dl>
  <dt>-x  --xml</dt>

  <dd>
  Produce the XML version name.xml of the input logfile. The input
  logfile is assumed to be a compressed log file
  (name.lox). Furthermore, the corresponding name.dic file should
  exist in the same directory. Note that this also implies that to
  convert a FITTEST-format log to XML, we first need to compress it.

  <p>It is possible to specify further additional options:

      <ul class=optionlist>
      <li>
      <dl>
      <dt>--appEventOnly</dt>
      
      <dd>This will only include application (high level) events in
      the resulting XML.</dd>

      </dl>
      </li>
      </ul>
  </p>

  </dd>
  </dl>
  </li>

  <li>
  <dl>
  <dt>-d  --daikon</dt>    

  <dd>Produce a Daikon trace-file name.dtrace from the input
  logfile. The input logfile is assume to be a compressed compressed
  log file (name.lox). Furthermore,
  the corresponding name.dic file should exist in the same directory. Note that
  this also implies that to convert a FITTEST-format log to Daikon, we
  first need to compress it.

   <p>It is possible to specify further additional options:

      <ul class=optionlist>
      <li>
      <dl>
      <dt>--dstat</dt>

      <dd>Print some statistics. WARNING: may cause memory-usage peak.</dd>
      </dl>
      </li>

      <li><dl>
      <dt> -o file  --output=file </dt>    
      <dd>Specify the name of the output file.</dd>
      </dl>
      </li>

      <li><dl>
      <dt>--genAuxvars</dt>
      <dd>Will cause auxiliary variables to be generated in the Daikon log.
      These variables log the types of normal variables, and whether or not the
      values of the latter are null or are undefined.
      </dd>
      </dl>
      </li>

      <li><dl>
      <dt>--varsSelect=regex</dt>    
      <dd>To specify which state-variables are included in the
      produced Daikon trace-file. A regular expression is expected to
      specify the selection. If this option is unspecified, then all
      variables are selected.
      </dd>
      </dl>
      </li>

      <li><dl>
      <dt>--appEvsSelect=regex</dt>  
      <dd>To specify which application (high level) events are included in the
      produced Daikon trace-file. A regular expression is expected to
      specify the selection. If this option is unspecified, then all
      application events are selected.
      </dd>
      </dl>
      </li>

      <li><dl>
      <dt>--llo=regex</dt>  
      <dd>
      Include only low-level events in the resulting Daikon
      trace-file. The regular expression specifies the name of the
      function whose low-level events are to be included.

          <p>It is possible to specify further additional options:
          <ul  class=optionlist>

          <li><dl>
          <dt>--lloMode=int</dt>  

          <dd>Specify how low-level events representing block/node
          visits in a function's control flow graph (CFG) are to be
          grouped. Possible values:

          <p>1: they are not grouped. </p>

          <p>2: nodes forming edges in the CFG are grouped together
          so that Daikon sees them as a single event representing
          edge-visits.</p>
 
          <p>3: nodes that form a path in the CFG are grouped
          together so that Daikon see them as a single event
          representing path-visits. The paths are however normalized by removing
         subsequent duplicate nodes in the path. For example paths
         [1,2,1,3] and [1,2,3,1] will both be normalized to [1,2,3]
         and thus will be treated as representing the same event.
         </p>

          <p>If this option is unspecified, the default is 1.</p>
  
          </dd>
          </dl>
          </li>

          <li><dl>
          <dt>--lloChopAt=int</dt>  

          <dd>When set, this will chop off the input logfile at the
          k-th event. It does not discriminate the event-types. This
          option is at the moment provided as a crude way to
          circumvent when the input log-file turns out to be too large
          for the low-level events extraction.
          
          If this option in unspecified, the default is no-chop.
          </dd>
          </dl>
          </li>
          </ul>
          </p>

      </dd>
      </dl>
      </li>

      </ul>
  </p>
  </dd>

  </dl>
  </li>

</ul>

<h3>Credits</h3>

Authors: Wishnu Prasetya, Alexander Elyasov, Jurriaan Hage. The
development is part of the EU-funded FITTEST project.

<p class="legalstuff">Copyright (C) Utrecht University, 2010.</p>

</body>
</html>